<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8">
	<title th:text="${titulo}"></title>
</head>

<body>

	<h3 th:text="${titulo}"></h3>

	<!--* th: para indicar que es una ruta de spring
			* @{/form} es la ruta target del metodo donde se enviara el formulario cuando se de clic en enviar
			  con method indicamos el tipo de metodo que es "post"
			  
			  El formulario se mapea automaticamente a una clase pojo, siempre y cuando los campos "name" del formulario
			  coincidan con los atributos de clase pojo
		-->
	<form th:action="@{/form}" th:object="${usuario}" method="post">

		<!--Campo para el atributo booleano. No se valida-->	
		<div>
			<label for="habilitar">Habilitar</label>
			<div>
				<input type="checkbox" id="habilitar" th:field="*{habilitar}">
			</div>
		</div>
		
		<!--Radio button-->
		<div>
			<label>Género</label>
			<!--each lee genero del FormController y guarda en gen-->
			<div th:each="gen: ${genero}">
				<input type="radio" th:field="*{genero}" th:value="${gen}">
				<label th:for="${#ids.prev('genero')}" th:text="${gen}"></label>
			</div>
			<div th:if="${#fields.hasErrors('genero')}" th:errors="*{genero}"></div>
		</div>
		
			
		<div>	
			<label for="pais">País</label>
			<div>
				<!--select es una lista desplegable. th:field esta mapeado al atributo pais de la clase usuario-->
				<!--Ahora se mapea directamente al objeto pais, osea completo-->
				<select id="pais" th:field="*{pais}">
					<!--Opciones de la lista desplegable-->
					<option value="">- seleccionar -</option>
					<!--iteramos con each. pais es el objeto que se crea para almacenar los elementos de la lista {paises}-->
					<!--th:text muestra el elemento pais del objeto que itero-->
					<!-- <option th:each="pais: ${paises}" th:text="${pais}" th:value="${pais}"></option> -->
					<!--Ahora iteramos paisesMap y usamos el metodo entrySet() que convierte de tipo Map a tipo Set para que sea iterable -->
					<!--th:text muestra el value del Map e internamente th:value envia el valor de la key-->
					<!-- <option th:each="pais: ${paisesMap.entrySet()}" th:text="${pais.value}" th:value="${pais.key}"></option> -->
					<!--Ahora usaremos una clase llamada Pais-->
					<option th:each="pais: ${listaPaises}" th:text="${pais.nombre}" th:value="${pais.id}"></option>					
				</select>
			</div>
			<div th:if="${#fields.hasErrors('pais')}" th:errors="*{pais}"></div>
		</div>
		
		<div>
			<label>Roles</label>
			<!--Iteramos el div y por lo tanto se itera el input. Esto para mostrar un checkbox por cada elemento del ArrayList
			en role se almacena cada elemento de listaRolesString -->
			<!-- <div th:each="role: ${listaRolesString}"> -->
				<!--Se comento lo anterior que trabaja con ArrayList. Ahora trabaja con Map -->
				<!-- <div th:each="role: ${listaRolesMap.entrySet()}"> -->
				<!-- Se comenta lo anterior porque ahora se trabaja con RoleServiceImpl-->
				<div th:each="role: ${listaRoles}">
				<!-- el th:value muestra el valor de role del th:each. th:value pasa su valor a th:field y a su vez lo pasa a la lista en la clase Usuario-->
				<!-- <input type="checkbox" th:field="*{roles}" th:value="${role}"> -->
				<!--Igual se comenta lo anterior porque ahora trabaja con Map. Enviamos la llave del map (key)-->
				<!-- <input type="checkbox" th:field="*{roles}" th:value="${role.key}"> -->
				<!-- Se comenta lo anterior porque ahora se trabaja con RoleServiceImpl-->
				<input type="checkbox" th:field="*{roles}" th:value="${role.id}"> 
				<!-- el th:for="${#ids.prev('roles')}" permite que al hacer clic sobre el texto, se seleccione el checkbox-->
				<!-- <label th:for="${#ids.prev('roles')}" th:text="${role}"></label> -->
				<!-- Se comenta lo anterior porque ahora trabaja con Map-->
				<!-- <label th:for="${#ids.prev('roles')}" th:text="${role.value}"></label> -->
				<!-- Se comentqa lo anterior porque ahora se trabaja con RoleServiceImpl-->
				<label th:for="${#ids.prev('roles')}" th:text="${role.nombre}"></label>
			</div>
			<div th:if="${#fields.hasErrors('roles')}" th:errors="*{roles}"></div>
		</div>

		<div>
			<label for="nombre">Identificador</label>
			<div>
				<input type="text" id="identificador" th:field="*{identificador}">
			</div>
			<div th:if="${#fields.hasErrors('identificador')}" th:errors="*{identificador}"></div>
		</div>


		<!--nombre y apellido se enviaran con informacion por defecto-->
		<div>
			<label for="nombre">Nombre</label>
			<div>
				<input type="text" id="nombre" th:field="*{nombre}">
			</div>
			<div th:if="${#fields.hasErrors('nombre')}" th:errors="*{nombre}"></div>
		</div>
		
		<div>
			<label for="apellido">Apellido</label>
			<div>
				<input type="text" id="apellido" th:field="*{apellido}">
			</div>
			<div th:if="${#fields.hasErrors('apellido')}" th:errors="*{apellido}"></div>
		</div>
		
		


		<!--Campo de nombre-->
		<!--for es una etiqueta para mapear o asignar el id, por lo tanto al for se le asigna lo mismo que id
		    sirve para usabilidad. Al dar clic en la etiqueta Username, automanticamente se posicionara en el input
		-->
		<div>
			<label for="username">Username</label>

			<div>
				<!--con th:value mostramos nuevamente el valor ingresado en el campo despues de que se intento enviar el formulario y este contenia errores
					en otras palabras no pierde la informacion ingresada previamente por el usuario
				-->
				<!--<input type="text" name="username" id="username" th:value="${usuario.username}">-->
				<!--th:field=*{} mapea o asigna un campo a un atributo de una clase-->
				<input type="text" id="username" th:field="*{username}">
			</div>
			<!--preguntamos si "error" (hashmap de java) que viene del controller trae errores y si trae errores preguntamos si la key contiene un error para el campo en este caso "username"
				si hay error lo mostramos con th:text
			-->
			<!--<div th:if="${error != null && error.containsKey('username')}" th:text="${error.username}"></div>-->
			
			<!--cambiamos por implementacion propia thymeleaf. #fields es un objeto helper para validar u obtener los mensajes de error
			#fields pregunta si hay errores en el campo username, si tiene lo mostramos con th:errors -->
			<div th:if="${#fields.hasErrors('username')}" th:errors="*{username}"></div>
		</div>

		<!--Campo password-->
		<div>
			<label for="password">Password</label>
			<div>
				<input type="password" th:field="*{password}" id="password">
			</div>
			<div th:if="${#fields.hasErrors('password')}" th:errors="*{password}"></div>
		</div>

		<div>
			<label for="email">Correo</label>
			<div>
				<!--en type podria ser email en lugar de text, para validar que sea un correo. Pero la validacion se hara con Spring-->
				<input type="text" id="email" th:field="*{email}">
			</div>
			<div th:if="${#fields.hasErrors('email')}" th:errors="*{email}"></div>
		</div>
		
		<div>
			<label for="cuenta">Cuenta</label>
			<div>
				<!--en type=number no permite introducir letras, solo numeros-->
				<input type="number" id="cuenta" th:field="*{cuenta}">
			</div>
			<div th:if="${#fields.hasErrors('cuenta')}" th:errors="*{cuenta}"></div>
		</div>
		
		<div>
			<label for="cuenta">Fecha de nacimiento</label>
			<div>
				<!--en type="date" maneja un formato para ingresar la fecha, el cual podria ser diferente del que valida Spring y por lo tanto no lo acepte-->
				<input type="date" id="fechaNacimiento" th:field="*{fechaNacimiento}" placeholder="yyyy-MM-dd">
			</div>
			<div th:if="${#fields.hasErrors('fechaNacimiento')}" th:errors="*{fechaNacimiento}"></div>
		</div>
		
		


		<!--Boton enviar-->
		<div>
			<div>
				<input type="submit" value="Enviar">
			</div>
		</div>
	</form>


</body>

</html>